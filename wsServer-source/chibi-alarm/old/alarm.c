/* Automatically generated by chibi-ffi; version: 0.5 */

#include <chibi/eval.h>
#include "stdio.h"
#include "stdbool.h"
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"
#include <signal.h>
#include <time.h>
/*
types: ()
enums: ()
*/

int timer_callback(void);

static sexp ctx2;


int set_timer(int usec,bool type)
{
  struct itimerval new_timer;
  struct itimerval old_timer;

  new_timer.it_value.tv_sec = 0;
  new_timer.it_value.tv_usec = 10000;
  new_timer.it_interval.tv_sec = 0;    
  new_timer.it_interval.tv_usec = 0;
    	
  if(usec ==0){
    (void) setitimer(ITIMER_REAL, NULL, NULL);
	  return 0;
  } 

  if (setitimer(ITIMER_REAL, &new_timer, NULL) == -1) {
	    perror("error calling setitimer()");
	    exit(1);
  }
  
  if (signal(SIGALRM, timer_callback) == SIG_ERR) {
    perror("Unable to catch SIGALRM");
    exit(1);
  }

  return 0;
}


int timer_callback(void)
{
 sexp ctx = ctx2;
 sexp_gc_var1(cmd); 
 sexp_gc_preserve1(ctx,cmd);
 cmd = sexp_list1(ctx, sexp_intern(ctx, "timer_callback", -1));
 sexp_eval(ctx, cmd, NULL);
 sexp_gc_release1(ctx);   
}

sexp sexp_set_timer_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_make_integer(ctx, set_timer(sexp_sint_value(arg0), sexp_truep(arg1)));
  return res;
}

sexp sexp_timer_callback_stub (sexp ctx, sexp self, sexp_sint_t n) {
  sexp res;
  res = sexp_make_integer(ctx, timer_callback());
  return res;
}

sexp sexp_init_library (sexp ctx, sexp self, sexp_sint_t n, sexp env, const char* version, const sexp_abi_identifier_t abi) {
  sexp_gc_var3(name, tmp, op);
  if (!(sexp_version_compatible(ctx, version, sexp_version)
        && sexp_abi_compatible(ctx, abi, SEXP_ABI_IDENTIFIER)))
    return SEXP_ABI_ERROR;
  sexp_gc_preserve3(ctx, name, tmp, op);
  op = sexp_define_foreign(ctx, env, "set_timer", 2, (sexp_proc1)sexp_set_timer_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_BOOLEAN);
  }
  op = sexp_define_foreign(ctx, env, "timer_callback", 0, sexp_timer_callback_stub);  
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  sexp_gc_release3(ctx);
  ctx2 = ctx;  
  sexp_preserve_object(ctx, ctx2);

  return SEXP_VOID;
}

