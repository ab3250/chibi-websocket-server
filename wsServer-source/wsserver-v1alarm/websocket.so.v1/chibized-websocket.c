/* Automatically generated by chibi-ffi; version: 0.4 */

#include <chibi/eval.h>
#include "stdio.h"
#include "stdbool.h"
#include "stdlib.h"
#include "stdio.h"
#include "unistd.h"
#include "ws.h"
#include <signal.h>
#include <time.h>
 
int timer_callback(void);

static sexp ctx2;

void onopen(int fd)
{ 
 sexp ctx = ctx2;
 sexp_gc_var1(cmd); 
 sexp_gc_preserve1(ctx,cmd);
 cmd = sexp_list2(ctx, sexp_intern(ctx, "onopen", -1),sexp_make_integer(ctx, fd));
 sexp_eval(ctx, cmd, NULL);
 sexp_gc_release1(ctx);
}

void onclose(int fd)
{
 sexp ctx = ctx2;
 sexp_gc_var1(cmd); 
 sexp_gc_preserve1(ctx,cmd);
 cmd = sexp_list2(ctx, sexp_intern(ctx, "onclose", -1),sexp_make_integer(ctx, fd));
 sexp_eval(ctx, cmd, NULL);
 sexp_gc_release1(ctx); 
}

void onmessage(int fd, const unsigned char *msg, uint64_t size, int type)
{  
 sexp ctx = ctx2;
 sexp_gc_var1(cmd); 
 sexp_gc_preserve1(ctx,cmd);
 cmd = sexp_list3(ctx,sexp_c_string(ctx, msg, -1),
        sexp_make_integer(ctx, size),sexp_make_integer(ctx, type));
 cmd = sexp_cons(ctx,sexp_make_integer(ctx, fd), cmd);
 cmd = sexp_cons(ctx,sexp_intern(ctx, "onmessage", -1),cmd); 
 sexp_eval(ctx, cmd, NULL);
 sexp_gc_release1(ctx);   
}

int ws_start(void)
{ 
 sexp ctx = ctx2;
 struct ws_events evs;
 evs.onopen    = &onopen;
 evs.onclose   = &onclose;
 evs.onmessage = &onmessage;
 usleep(500000);
 setbuf(stdout, NULL); 
 printf("Server Initialized!\n");   
 ws_socket(&evs, 8080, 0);    	
}

int ws_set_timer(int usec,bool type)
{
 printf("debug1 %i", usec);
 
 struct itimerval new_timer;
 struct itimerval old_timer;

    new_timer.it_value.tv_sec = 1;
    new_timer.it_value.tv_usec = 0;
    new_timer.it_interval.tv_sec = 0;    
    new_timer.it_interval.tv_usec = 300 * 1000;

     	
 if(usec ==0){
	(void) setitimer(ITIMER_REAL, NULL, NULL);
	return 0;
 } 

  if (setitimer(ITIMER_REAL, &new_timer, NULL) == -1) {
	    perror("error calling setitimer()");
	    exit(1);
  }
  
  if (signal(SIGALRM, timer_callback) == SIG_ERR) {
    perror("Unable to catch SIGALRM");
    exit(1);
  }

 



 /* 
  alarm(10);	
  
  
  
  
  if (type == true){  
	it_val.it_value.tv_sec =     usec/1000;
  	it_val.it_value.tv_usec =    (usec*1000) % 1000000;  	
  	it_val.it_interval.tv_sec =   usec/1000;;
  	it_val.it_interval.tv_usec =  (usec*1000) % 1000000;	
  }  	
 
  if(type == false){
 	it_val.it_value.tv_sec =     0;
  	it_val.it_value.tv_usec =    0;  	
  	it_val.it_interval.tv_sec =     usec/1000;
  	it_val.it_interval.tv_usec =    (usec*1000) % 1000000;	

  }
  
 
  
return(0);
*/
return 0;
}

int timer_callback(void)
{
 sexp ctx = ctx2;
 sexp_gc_var1(cmd); 
 sexp_gc_preserve1(ctx,cmd);
 cmd = sexp_list1(ctx, sexp_intern(ctx, "timer_callback", -1));
 sexp_eval(ctx, cmd, NULL);
 sexp_gc_release1(ctx);   
}
/* ws_set_timer */
sexp sexp_ws_set_timer_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_make_integer(ctx, ws_set_timer(sexp_sint_value(arg0), sexp_truep(arg1)));
  return res;
}

sexp sexp_ws_socket_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2) {
  sexp res;
  if (! sexp_exact_integerp(arg1))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg1);
  if (! sexp_exact_integerp(arg2))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg2);
  res = sexp_make_integer(ctx, ws_socket(arg0, sexp_sint_value(arg1), sexp_sint_value(arg2)));
  return res;
}

sexp sexp_ws_get_state_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_make_integer(ctx, ws_get_state(sexp_sint_value(arg0)));
  return res;
}

sexp sexp_ws_getaddress_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_c_string(ctx, ws_getaddress(sexp_sint_value(arg0)), -1);
  return res;
}

sexp sexp_ws_close_client_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  res = sexp_make_integer(ctx, ws_close_client(sexp_sint_value(arg0)));
  return res;
}

sexp sexp_ws_sendframe_bin_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2, sexp arg3) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  if (! sexp_stringp(arg1))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg1);
  if (! sexp_exact_integerp(arg2))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg2);
  res = sexp_make_integer(ctx, ws_sendframe_bin(sexp_sint_value(arg0), sexp_string_data(arg1), sexp_uint_value(arg2), sexp_truep(arg3)));
  return res;
}

sexp sexp_ws_sendframe_txt_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  if (! sexp_stringp(arg1))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg1);
  res = sexp_make_integer(ctx, ws_sendframe_txt(sexp_sint_value(arg0), sexp_string_data(arg1), sexp_truep(arg2)));
  return res;
}

sexp sexp_ws_sendframe_stub (sexp ctx, sexp self, sexp_sint_t n, sexp arg0, sexp arg1, sexp arg2, sexp arg3, sexp arg4) {
  sexp res;
  if (! sexp_exact_integerp(arg0))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg0);
  if (! sexp_stringp(arg1))
    return sexp_type_exception(ctx, self, SEXP_STRING, arg1);
  if (! sexp_exact_integerp(arg2))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg2);
  if (! sexp_exact_integerp(arg4))
    return sexp_type_exception(ctx, self, SEXP_FIXNUM, arg4);
  res = sexp_make_integer(ctx, ws_sendframe(sexp_sint_value(arg0), sexp_string_data(arg1), sexp_uint_value(arg2), sexp_truep(arg3), sexp_sint_value(arg4)));
  return res;
}

sexp sexp_timer_callback_stub (sexp ctx, sexp self, sexp_sint_t n) {
  sexp res;
  res = sexp_make_integer(ctx, timer_callback());
  return res;
}


sexp sexp_ws_start_stub (sexp ctx, sexp self, sexp_sint_t n) {
  sexp res;
  res = sexp_make_integer(ctx, ws_start());
  return res;
}


sexp sexp_init_library (sexp ctx, sexp self, sexp_sint_t n, sexp env, const char* version, const sexp_abi_identifier_t abi) {
  sexp sexp_ws_events_type_obj;
  sexp_gc_var3(name, tmp, op);
  if (!(sexp_version_compatible(ctx, version, sexp_version)
        && sexp_abi_compatible(ctx, abi, SEXP_ABI_IDENTIFIER)))
    return SEXP_ABI_ERROR;
  sexp_gc_preserve3(ctx, name, tmp, op);
  name = sexp_c_string(ctx, "ws_events", -1);
  sexp_ws_events_type_obj = sexp_register_c_type(ctx, name, sexp_finalize_c_type);
  tmp = sexp_string_to_symbol(ctx, name);
  sexp_env_define(ctx, env, tmp, sexp_ws_events_type_obj);
  op = sexp_define_foreign(ctx, env, "ws_socket", 3, sexp_ws_socket_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "ws_get_state", 1, sexp_ws_get_state_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "ws_getaddress", 1, sexp_ws_getaddress_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "ws_close_client", 1, sexp_ws_close_client_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  op = sexp_define_foreign(ctx, env, "ws_sendframe_bin", 4, sexp_ws_sendframe_bin_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_argn_type(op) = sexp_make_vector(ctx, SEXP_ONE, sexp_make_fixnum(SEXP_OBJECT));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ZERO, sexp_make_fixnum(SEXP_BOOLEAN));
  }
  op = sexp_define_foreign(ctx, env, "ws_sendframe_txt", 3, sexp_ws_sendframe_txt_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_BOOLEAN);
  }
  op = sexp_define_foreign(ctx, env, "ws_sendframe", 5, sexp_ws_sendframe_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_STRING);
    sexp_opcode_arg3_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_argn_type(op) = sexp_make_vector(ctx, SEXP_TWO, sexp_make_fixnum(SEXP_OBJECT));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ZERO, sexp_make_fixnum(SEXP_BOOLEAN));
    sexp_vector_set(sexp_opcode_argn_type(op), SEXP_ONE, sexp_make_fixnum(SEXP_FIXNUM));
  }
  op = sexp_define_foreign(ctx, env, "ws_set_timer", 2, sexp_ws_set_timer_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg1_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
    sexp_opcode_arg2_type(op) = sexp_make_fixnum(SEXP_BOOLEAN);
  }  
  op = sexp_define_foreign(ctx, env, "timer_callback", 0, sexp_timer_callback_stub);
  op = sexp_define_foreign(ctx, env, "ws_start", 0, sexp_ws_start_stub);
  if (sexp_opcodep(op)) {
    sexp_opcode_return_type(op) = sexp_make_fixnum(SEXP_FIXNUM);
  }
  sexp_gc_release3(ctx);

  ctx2 = ctx;  
  sexp_preserve_object(ctx, ctx2);

  return SEXP_VOID;
}

